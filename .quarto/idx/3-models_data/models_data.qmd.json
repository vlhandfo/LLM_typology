{"title":"Models and Data","markdown":{"yaml":{"execute":{"echo":false}},"headingText":"Models and Data","containsRefs":false,"markdown":"\n\n\n\n## The HPLT Project\n\nThe High-Performance Language Technology (HPLT) project seeks to combine large amounts of data and tools for high-performance computing to produce and make high-quality language models available @de-gibert-etal-2024-new-massive. It provides large datasets for a variety of languages and base models trained on them. *These datasets and models are the foundation of our experiments.*\n\n**TODO**: write about them pretraining the models and providing intermediate checkpoints\n\n## Evaluation Data\n<!-- \\citep[UD;][]{nivre-etal-2017-universal, nivre-etal-2020-universal} -->\nTo evaluate each language model, we use the Universal Dependencies 2.14 treebanks (UD; @nivre-etal-2017-universal, -@nivre-etal-2020-universal). The treebanks are formatted in the same way which allows for simpler comparison of the results of the cross-linguistic experiments. Likewise, as the treebanks include text from different genres, the data covers a broad range of language use. \n\nThe treebanks for the selected languages vary in size, both in terms of number of words and sentences. To ensure the comparability of the results, subsets of each partition of the treebanks were shuffled and normalized by the number of word forms. While the number of sentences in the result subsets still varies, this step makes sure that each model encounters roughly the same number of tokens during the fine-tuning and evaluation steps.\n\n## Language and Feature Selection\n\nThe languages for this study were chosen based on two criteria: the availability of resources and linguistic diversity. Available resources include the size of the dataset from the HPLT project and the treebanks from Universal Dependencies, as well as the typological features available in the databases (see @sec-databases). Linguistic diversity was determined by examining typological, genealogical, and geographic differences available in WALS, specifically the [WALS 100-sample](https://wals.info/chapter/s1#3.1._The_WALS_samples). \n\nThe features were selected from WALS and Grambank, and those from the WALS database were manually coverted to the Question: Binary Encoding format of the Grambank features (e.g., \"81A: Order of Subject, Object and Verb\" from WALS became *WALS81A: Is the dominant word order in a transitive clause SVO?*)\n\nAfter identifying relevant morphosyntactic features, the set was filtered, removing features with no variance and/or missing values for any selected language. Then, each feature was categorized into a group according to the type of feature it is related to. The largest group, *marking*, relate to grammatical phenomena which morphologically indicated on words. *Order* are features related to aspects of word order and syntax. Features in the group *formation* represent different methods for creating words and clauses. The groups *determiners* and *lexicon* correspond to the types of determiners and words, respectively. Lastly, *case* pertains to morphological marking of cases. A complete list of selected features is shown in @tbl-all-features.\n\nWith the features and language selected, it was straight-forward to combine all of the values to create a binary vector representation for each language. @fig-pca-langs shows the PCA of the languages according to these vector representations.\n\n:::{#fig-pca-langs}\n```{python}\n\nimport pandas as pd\nimport altair as alt\n\nfrom itables import show\nfrom pathlib import Path\n\nfrom sklearn.decomposition import PCA\n\nDATA_DIR = Path(\"../data\")\n\nassert DATA_DIR.exists() and DATA_DIR.is_dir(), \"Invalid path to data directory.\"\n\nfeats_df = pd.read_csv(DATA_DIR / \"feature_values.csv\", index_col=0).set_index('Feature')\n\n# Plot the representation of each language in 2D space\npca = PCA(n_components=2)\npca_result = pca.fit_transform(feats_df.drop(columns=['Name', 'Group']).T)\n\n# Create a DataFrame with the PCA results\npca_df = pd.DataFrame(pca_result, columns=['x', 'y'])\npca_df['Language'] = feats_df.T.index[:-2]\n\n# Plot the PCA results\nchart = alt.Chart(pca_df).mark_circle(size=50, fillOpacity=1).encode(\n    x=alt.X('x', axis=alt.Axis(labels=False, title=\"\")),\n    y=alt.Y('y', axis=alt.Axis(labels=False, title=\"\")),\n    tooltip=['Language'],\n    color=alt.Color('Language', scale=alt.Scale(scheme=\"category20\"))\n).properties(\n    title='PCA of Language Features',\n    height=350,\n    width=350\n)\nchart.show()\n```\n\nPCA of the selected languages according to their feature values.\n:::\n\n### Selected Features\n\n:::{#tbl-all-features tbl-cap-location=bottom}\n\n```{python}\nshow(\n  feats_df.reset_index()[['Feature', 'Name', 'Group']],\n  classes=\"compact\"\n  )\n```\n\nAn overview of all selected features and assigned group. The prefix GB indicates a feature from Grambank, and WALS is the adapted feature from the WALS database.\n:::","srcMarkdownNoYaml":"\n\n# Models and Data\n\n\n## The HPLT Project\n\nThe High-Performance Language Technology (HPLT) project seeks to combine large amounts of data and tools for high-performance computing to produce and make high-quality language models available @de-gibert-etal-2024-new-massive. It provides large datasets for a variety of languages and base models trained on them. *These datasets and models are the foundation of our experiments.*\n\n**TODO**: write about them pretraining the models and providing intermediate checkpoints\n\n## Evaluation Data\n<!-- \\citep[UD;][]{nivre-etal-2017-universal, nivre-etal-2020-universal} -->\nTo evaluate each language model, we use the Universal Dependencies 2.14 treebanks (UD; @nivre-etal-2017-universal, -@nivre-etal-2020-universal). The treebanks are formatted in the same way which allows for simpler comparison of the results of the cross-linguistic experiments. Likewise, as the treebanks include text from different genres, the data covers a broad range of language use. \n\nThe treebanks for the selected languages vary in size, both in terms of number of words and sentences. To ensure the comparability of the results, subsets of each partition of the treebanks were shuffled and normalized by the number of word forms. While the number of sentences in the result subsets still varies, this step makes sure that each model encounters roughly the same number of tokens during the fine-tuning and evaluation steps.\n\n## Language and Feature Selection\n\nThe languages for this study were chosen based on two criteria: the availability of resources and linguistic diversity. Available resources include the size of the dataset from the HPLT project and the treebanks from Universal Dependencies, as well as the typological features available in the databases (see @sec-databases). Linguistic diversity was determined by examining typological, genealogical, and geographic differences available in WALS, specifically the [WALS 100-sample](https://wals.info/chapter/s1#3.1._The_WALS_samples). \n\nThe features were selected from WALS and Grambank, and those from the WALS database were manually coverted to the Question: Binary Encoding format of the Grambank features (e.g., \"81A: Order of Subject, Object and Verb\" from WALS became *WALS81A: Is the dominant word order in a transitive clause SVO?*)\n\nAfter identifying relevant morphosyntactic features, the set was filtered, removing features with no variance and/or missing values for any selected language. Then, each feature was categorized into a group according to the type of feature it is related to. The largest group, *marking*, relate to grammatical phenomena which morphologically indicated on words. *Order* are features related to aspects of word order and syntax. Features in the group *formation* represent different methods for creating words and clauses. The groups *determiners* and *lexicon* correspond to the types of determiners and words, respectively. Lastly, *case* pertains to morphological marking of cases. A complete list of selected features is shown in @tbl-all-features.\n\nWith the features and language selected, it was straight-forward to combine all of the values to create a binary vector representation for each language. @fig-pca-langs shows the PCA of the languages according to these vector representations.\n\n:::{#fig-pca-langs}\n```{python}\n\nimport pandas as pd\nimport altair as alt\n\nfrom itables import show\nfrom pathlib import Path\n\nfrom sklearn.decomposition import PCA\n\nDATA_DIR = Path(\"../data\")\n\nassert DATA_DIR.exists() and DATA_DIR.is_dir(), \"Invalid path to data directory.\"\n\nfeats_df = pd.read_csv(DATA_DIR / \"feature_values.csv\", index_col=0).set_index('Feature')\n\n# Plot the representation of each language in 2D space\npca = PCA(n_components=2)\npca_result = pca.fit_transform(feats_df.drop(columns=['Name', 'Group']).T)\n\n# Create a DataFrame with the PCA results\npca_df = pd.DataFrame(pca_result, columns=['x', 'y'])\npca_df['Language'] = feats_df.T.index[:-2]\n\n# Plot the PCA results\nchart = alt.Chart(pca_df).mark_circle(size=50, fillOpacity=1).encode(\n    x=alt.X('x', axis=alt.Axis(labels=False, title=\"\")),\n    y=alt.Y('y', axis=alt.Axis(labels=False, title=\"\")),\n    tooltip=['Language'],\n    color=alt.Color('Language', scale=alt.Scale(scheme=\"category20\"))\n).properties(\n    title='PCA of Language Features',\n    height=350,\n    width=350\n)\nchart.show()\n```\n\nPCA of the selected languages according to their feature values.\n:::\n\n### Selected Features\n\n:::{#tbl-all-features tbl-cap-location=bottom}\n\n```{python}\nshow(\n  feats_df.reset_index()[['Feature', 'Name', 'Group']],\n  classes=\"compact\"\n  )\n```\n\nAn overview of all selected features and assigned group. The prefix GB indicates a feature from Grambank, and WALS is the adapted feature from the WALS database.\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"models_data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.15","bibliography":["../references.bib"],"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}